// Gradle build script for SemVer plugin project.
import groovy.text.SimpleTemplateEngine
import org.ajoberstar.grgit.Grgit

// Buildscript dependencies
buildscript {
    repositories { jcenter() }
    dependencies {
        // Git gradle plugin
        classpath 'org.ajoberstar:gradle-git:0.12.0'

        // Bintray plugin
        classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.0'

        classpath 'org.jfrog.buildinfo:build-info-extractor-gradle:2.2.5'

        // Cobertura plugin
        //classpath "net.saliman:gradle-cobertura-plugin:2.2.5"

        // A previous version of our plugin
        classpath 'com.github.tagc:semver-plugin:0.4.0'
    }
}

// Plugins
apply plugin: 'groovy'
apply plugin: 'eclipse'
apply plugin: 'maven'
apply plugin: 'distribution'
apply plugin: 'maven-publish'
apply plugin: 'com.jfrog.bintray'
apply plugin: 'artifactory'
apply plugin: 'sonar-runner'
apply plugin: 'codenarc'
//apply plugin: 'net.saliman.cobertura'
apply plugin: "jacoco"
apply plugin: 'semver' //Plugin applies itself!

// Artifact meta-data
archivesBaseName = 'semver-plugin'
group = 'com.github.tagc'
description = 'Semantic versioning plugin for managing the version numbering of Git-controlled projects'

// Set version
semver {
    versionFilePath = 'version.properties'
    snapshotBump = 'PATCH'    
}

task printVersion(description: 'Prints the current project version.') << { println "Version: $project.version" }

// Project dependencies
repositories { jcenter() }

dependencies {
    // We use the latest groovy 2.x version for building this library
    compile 'org.codehaus.groovy:groovy-all:2.3.6'

    // Gradle API
    compile gradleApi()

    // Git gradle plugin
    compile 'org.ajoberstar:gradle-git:0.12.0'

    // jcip annotations
    compile 'net.jcip:jcip-annotations:1.0'

    // We use the awesome Spock testing and specification framework
    testCompile 'org.spockframework:spock-core:0.7-groovy-2.0'
    testCompile 'junit:junit:4.11'
}

configurations.all {
    resolutionStrategy {
        // Cobertura includes an ASM version that can't handle Java 8, ASM 5.0.3
        //handles Java8
        //force 'org.ow2.asm:asm:5.0.3'
        //forcedModules = [ 'org.ow2.asm:asm:5.0.3' ]
    }
}

// Integration tests.
sourceSets {
    integrationTest {
        groovy.srcDir file('src/integTest/groovy')
        resources.srcDir file('src/integTest/resources')
        compileClasspath = sourceSets.main.output + configurations.testRuntime
        runtimeClasspath = output + compileClasspath
    }
}

task integrationTest(type: Test) {
    description = 'Runs the integration tests.'
    group = 'verification'
    testClassesDir = sourceSets.integrationTest.output.classesDir
    classpath = sourceSets.integrationTest.runtimeClasspath
    
    jacoco {
        destinationFile = file("$buildDir/jacoco/integrationTest.exec")
        classDumpFile = file("$buildDir/classes/integrationTest")
     }
}

integrationTest.reports.html.destination = file("$buildDir/reports/intTests")

check.dependsOn integrationTest

// Copy tasks
task copyDoc(type: Copy, description: "Copies documentation from build directory to project root directory.") {
    from "$buildDir/docs"
    into "$projectDir/docs"
}

task deleteDoc(type: Delete, description: "Deletes documentation folder.") {
	delete "$projectDir/docs"
}

task copyHealth(description: "Copies project health data to project root directory.") << {
    def dirMap = ["reports/codenarc":"codenarc", "reports/jacoco/test/html":"jacoco"]
    dirMap.each { source, dest ->
        copy {
            from "$buildDir/$source"
            into "$projectDir/health/$dest"
            exclude '*.xml'
        }
    }
}

task deleteHealth(type: Delete, description: "Deletes project health folder") {
	delete "$projectDir/health"
}

clean.finalizedBy([deleteDoc, deleteHealth])

groovydoc.finalizedBy(copyDoc)
check.finalizedBy(copyHealth)

// README generation.
task generateReadme(description: "Generates the README file", group: "documentation") {
    dependsOn 'check'
    
    doLast {
        def templateFile = new File("$projectDir/README_Template")
        assert (templateFile.isFile())
        
        def repo = Grgit.open(project.file("$projectDir"))
        def currentBranch = repo.branch.current.name
        if (currentBranch != 'master') currentBranch = 'develop'
        
        
        def template = templateFile.text
        def binding = [
            "jacocoCoverage":"$project.ext.jacocoCoverage",
            "p1Issues":"$project.ext.codenarcP1",
            "p2Issues":"$project.ext.codenarcP2",
            "p3Issues":"$project.ext.codenarcP3",
            "gitBranch":"$currentBranch"
        ]
        
        def engine = new SimpleTemplateEngine()
        def result = engine.createTemplate(template).make(binding).toString()
        
        // Save back to README.md
        def readmeFile = new File("$projectDir/README.md")
        def w = readmeFile.newWriter()
        w << result
        w.close()
    }
}

build.dependsOn generateReadme

// Additional artifact declarations
task sourcesJar(type: Jar) {
    baseName archivesBaseName
    classifier 'sources'
    from sourceSets.main.allSource
}

task groovydocJar(type: Jar, dependsOn: groovydoc) {
    baseName archivesBaseName
    classifier 'groovydoc'
    from groovydoc.destinationDir
}

artifacts {
    archives sourcesJar
    archives groovydocJar
}

// Artifact distribution declarations
distributions {
    main {
        baseName archivesBaseName

        contents { from { libsDir } }
    }

    docs {
        baseName = "$archivesBaseName-docs"

        contents {
            from(libsDir) {
                include sourcesJar.archiveName
                include groovydocJar.archiveName
            }
        }
    }
}

ext {
    artifactorySnapshotRepoKey = "oss-snapshot-local"
    artifactoryReleaseRepoKey = "oss-release-local"
    unknownPropertyDefault = 'Unknown'
}

// Maven publications
publishing {
    publications {
        plugin(MavenPublication) {
            from components.java
            artifactId archivesBaseName

            pom.withXml {
                def root = asNode()
                root.appendNode('name', 'Gradle SemVer plugin')
                root.appendNode('description', description)
                root.appendNode('inceptionYear', '2014')

                def license = root.appendNode('licenses').appendNode('license')
                license.appendNode('name', 'MIT License')
                license.appendNode('url', 'http://www.opensource.org/licenses/mit-license.php')
                license.appendNode('distribution', 'repo')

                def developer = root.appendNode('developers').appendNode('developer')
                developer.appendNode('id', 'tagc')
                developer.appendNode('name', 'David Fallah')
                developer.appendNode('email', 'davidfallah1@gmail.com')
            }

            artifact sourcesJar
            artifact groovydocJar
        }
    }
}

// Bintray configuration

// Do not permit snapshot versions to be uploaded to Bintray.
project.tasks.bintrayUpload.onlyIf { !project.version.toString().endsWith('-SNAPSHOT') }

bintray {
    user = bintrayUsername
    key = bintrayApiKey

    publications = ['plugin']
    publish = true

    pkg {
        repo = 'gradle-plugins'
        name = 'gradle-semver-plugin'
        desc = description
        websiteUrl = 'https://github.com/TAGC/Semver'
        issueTrackerUrl = 'https://github.com/TAGC/Semver/issues'
        vcsUrl = 'https://github.com/TAGC/Semver.git'
        licenses = ['MIT']
        labels = [
            'gradle',
            'semantic-versioning'
        ]
        publicDownloadNumbers = true

        version {
            project.afterEvaluate {
                assert project.version
                name = project.version
            }
        }
    }
}

// Artifactory configuration
artifactory {
    contextUrl = 'http://oss.jfrog.org/artifactory'
    publish {
        repository {
            project.afterEvaluate {
                assert project.version
                repoKey = project.version.toString().endsWith('-SNAPSHOT') ? artifactorySnapshotRepoKey : artifactoryReleaseRepoKey
            }
            username = bintrayUsername
            password = bintrayApiKey
        }
        defaults {
            publishConfigs('archives')
            publishPom = true
            publishIvy = false
            publishBuildInfo = true
            publishArtifacts = true
        }
    }
}

// SonarQube
sonarRunner {
    sonarProperties {
        property 'sonar.host.url', 'http://54.72.57.177:9000'
        property 'sonar.jdbc.url', 'jdbc:mysql://54.72.57.177:3306/sonar?useUnicode=true&characterEncoding=utf8&rewriteBatchedStatements=true&useConfigs=maxPerformance'
        property 'sonar.jdbc.driverClassName', 'com.mysql.jdbc.Driver'
        property 'sonar.jdbc.username', "${sonarJDBCUsername}"
        property 'sonar.jdbc.password', "${sonarJDBCPassword}"
        property 'sonar.login', "${sonarLogin}"
        property 'sonar.password', "${sonarPassword}"
        property 'sonar.language', 'grvy'
        property 'source-encoding', 'UTF-8'
        property 'sonar.groovy.codenarc.reportPath', "$buildDir/reports/codenarc/main.xml"
        property 'sonar.groovy.cobertura.reportPath', "$buildDir/reports/cobertura/coverage.xml"
    }
}

project.tasks.findByName('sonarRunner').dependsOn 'check'

// Cobertura
//check.dependsOn 'cobertura'

//cobertura {
//    coverageFormats = [ 'html', 'xml' ]
//}

// Codenarc
codenarc {
    configFile = new File("$projectDir/config/codenarc/rules.groovy")
    ignoreFailures = true
}

tasks.withType(CodeNarc) {
    reports {
        xml.enabled = true
        html.enabled = true
    }
}

codenarcMain {
    outputs.upToDateWhen { false }
    
    doLast {
        saveCodenarcData()
    }
}

def saveCodenarcData() {
    def codenarcReport = new File('./build/reports/codenarc/main.xml')
    if (!codenarcReport.isFile()) {
        project.ext.codenarcP1 = "$unknownPropertyDefault"
        project.ext.codenarcP2 = "$unknownPropertyDefault"
        project.ext.codenarcP3 = "$unknownPropertyDefault"
        return
    }

    def pattern = ~/(?s)<CodeNarc.+>/
    def xml = (codenarcReport.text =~ pattern)[0]

    def parser = new XmlSlurper()
    def rootNode = parser.parseText(xml)

    project.ext.codenarcP1 = rootNode.PackageSummary.@priority1.text()
    project.ext.codenarcP2 = rootNode.PackageSummary.@priority2.text()
    project.ext.codenarcP3 = rootNode.PackageSummary.@priority3.text()
}

// Jacoco
jacocoTestReport {
    executionData test, integrationTest
    
    reports {
        xml.enabled true
        html.enabled true
    }
}

check.finalizedBy(jacocoTestReport)

jacocoTestReport << {
    saveJacocoTestCoverage()
}

def saveJacocoTestCoverage() {
    def coverageFile = new File("${jacoco.reportsDir}/test/jacocoTestReport.xml")
    if (!coverageFile.isFile()) {
        project.ext.jacocoCoverage = "$unknownPropertyDefault"
        return
    }

    def pattern = ~/<report.+>/
    def xml = (coverageFile.text =~ pattern)[0]

    def parser = new XmlSlurper()
    def rootNode = parser.parseText(xml)

    def instructionCounter = rootNode.counter.find { it.@type.text() == 'INSTRUCTION' }

    def instructionsMissed = instructionCounter.@missed.text().toInteger()
    def instructionsCovered = instructionCounter.@covered.text().toInteger()

    def totalInstructions = instructionsMissed + instructionsCovered
    def coverage = instructionsCovered / totalInstructions
    
    project.ext.jacocoCoverage = sprintf('%.1f%%', coverage*100)
}
